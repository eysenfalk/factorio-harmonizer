#!/usr/bin/env python3
"""
Visualizer
Generates visual representations of conflicts, dependencies, and patches
"""

import logging
from typing import Dict, List, Any, Optional, Set, Tuple
from pathlib import Path
import json

from data_models import (
    ConflictSeverity, DependencyType, ModCompatibilityReport, PatchSuggestion,
    VisualizationData, severity_to_color, dependency_to_edge_style,
    create_prototype_key, parse_prototype_key
)

class ConflictVisualizer:
    """Creates visual representations of mod conflicts and solutions"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def generate_conflict_report(self, report: ModCompatibilityReport, patches: List[PatchSuggestion]) -> str:
        """Generate a comprehensive text-based conflict report"""
        lines = []
        
        # Header
        lines.append("üéØ FACTORIO MOD HARMONIZER - CONFLICT ANALYSIS REPORT")
        lines.append("=" * 70)
        lines.append(f"Analysis Date: {report.analysis_timestamp}")
        lines.append(f"Analyzed Mods: {', '.join(report.analyzed_mods)}")
        lines.append("")
        
        # Summary
        lines.append("üìä SUMMARY")
        lines.append("-" * 30)
        lines.append(f"Total Prototypes Analyzed: {report.total_prototypes}")
        lines.append(f"Conflicted Prototypes: {report.conflicted_prototypes}")
        lines.append(f"Critical Issues: {report.critical_issues}")
        lines.append(f"High Priority Issues: {report.high_issues}")
        lines.append(f"Medium Priority Issues: {report.medium_issues}")
        lines.append(f"Low Priority Issues: {report.low_issues}")
        lines.append("")
        
        # Critical Issues Detail
        critical_issues = report.get_critical_issues()
        if critical_issues:
            lines.append("üö® CRITICAL ISSUES REQUIRING IMMEDIATE ATTENTION")
            lines.append("-" * 50)
            
            for i, issue in enumerate(critical_issues, 1):
                lines.append(f"{i}. {issue.title}")
                lines.append(f"   Severity: {issue.severity.value.upper()}")
                lines.append(f"   Affected: {', '.join(issue.affected_prototypes)}")
                lines.append(f"   Conflicting Mods: {' ‚Üí '.join(issue.conflicting_mods)}")
                lines.append(f"   Problem: {issue.description}")
                lines.append(f"   Root Cause: {issue.root_cause}")
                lines.append("   Suggested Solutions:")
                for fix in issue.suggested_fixes:
                    lines.append(f"     ‚Ä¢ {fix}")
                lines.append("")
        
        # Patch Solutions
        if patches:
            lines.append("üîß GENERATED PATCH SOLUTIONS")
            lines.append("-" * 40)
            
            for i, patch in enumerate(patches, 1):
                lines.append(f"{i}. {patch.patch_id}")
                lines.append(f"   Description: {patch.description}")
                lines.append(f"   Target: {patch.target_mod}/{patch.target_file}")
                lines.append(f"   Impact Level: {patch.estimated_impact.value.upper()}")
                lines.append(f"   Fixes Issues: {', '.join(patch.issue_ids)}")
                lines.append("")
                lines.append("   Generated Lua Code:")
                lines.append("   " + "-" * 30)
                for line in patch.lua_code.split('\n'):
                    lines.append(f"   {line}")
                lines.append("")
        
        # Recommendations
        lines.append("üí° RECOMMENDATIONS")
        lines.append("-" * 25)
        
        if report.critical_issues > 0:
            lines.append("‚ö†Ô∏è  URGENT: Apply generated patches immediately to resolve critical conflicts")
        
        if report.high_issues > 0:
            lines.append("üî∂ HIGH: Review high-priority issues for potential gameplay impact")
        
        if report.conflicted_prototypes > 0:
            lines.append("üìã GENERAL: Consider mod load order optimization")
        
        lines.append("‚úÖ TESTING: Test all patches in a development environment before production use")
        lines.append("")
        
        # Footer
        lines.append("=" * 70)
        lines.append("Generated by Factorio Mod Harmonizer")
        
        return "\n".join(lines)
    
    def generate_patch_files(self, patches: List[PatchSuggestion], output_dir: Path) -> List[Path]:
        """Generate actual patch files that can be used as Factorio mods"""
        output_dir = Path(output_dir)
        output_dir.mkdir(exist_ok=True)
        
        created_files = []
        
        # Group patches by target mod
        patches_by_mod = {}
        for patch in patches:
            if patch.target_mod not in patches_by_mod:
                patches_by_mod[patch.target_mod] = []
            patches_by_mod[patch.target_mod].append(patch)
        
        for mod_name, mod_patches in patches_by_mod.items():
            mod_dir = output_dir / mod_name
            mod_dir.mkdir(exist_ok=True)
            
            # Create info.json
            info_json = {
                "name": mod_name,
                "version": "1.0.0",
                "title": "Factorio Harmonizer Compatibility Patch",
                "author": "Factorio Harmonizer",
                "description": f"Auto-generated compatibility patch resolving {len(mod_patches)} conflicts",
                "dependencies": ["base"]
            }
            
            info_file = mod_dir / "info.json"
            with open(info_file, 'w', encoding='utf-8') as f:
                json.dump(info_json, f, indent=2)
            created_files.append(info_file)
            
            # Group patches by target file
            patches_by_file = {}
            for patch in mod_patches:
                if patch.target_file not in patches_by_file:
                    patches_by_file[patch.target_file] = []
                patches_by_file[patch.target_file].append(patch)
            
            # Create patch files
            for file_name, file_patches in patches_by_file.items():
                patch_file = mod_dir / file_name
                
                lua_content = []
                lua_content.append("-- Auto-generated compatibility patch")
                lua_content.append("-- Generated by Factorio Mod Harmonizer")
                lua_content.append(f"-- Resolves {len(file_patches)} conflict(s)")
                lua_content.append("")
                
                for patch in file_patches:
                    lua_content.append(f"-- Patch: {patch.patch_id}")
                    lua_content.append(f"-- Description: {patch.description}")
                    lua_content.append(f"-- Fixes: {', '.join(patch.issue_ids)}")
                    lua_content.append("")
                    lua_content.append(patch.lua_code)
                    lua_content.append("")
                
                with open(patch_file, 'w', encoding='utf-8') as f:
                    f.write("\n".join(lua_content))
                created_files.append(patch_file)
        
        self.logger.info(f"Generated {len(created_files)} patch files in {output_dir}")
        return created_files

# Test function
def test_visualizer():
    """Test the visualizer with real analysis data"""
    print("üß™ Testing Visualizer...")
    
    # Set up logging
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
    
    # Import and run the full analysis pipeline
    from dependency_analyzer import test_dependency_analyzer
    
    print("\nüîç Running full analysis pipeline...")
    report, patches = test_dependency_analyzer()
    
    print("\nüé® Generating visualizations...")
    visualizer = ConflictVisualizer()
    
    # Generate text report
    print("\nüìÑ Generating text report...")
    text_report = visualizer.generate_conflict_report(report, patches)
    
    # Save text report
    text_output = Path("./logs/conflict_report.txt")
    with open(text_output, 'w', encoding='utf-8') as f:
        f.write(text_report)
    print(f"Text report saved to: {text_output}")
    
    # Generate patch files
    print("\nüîß Generating patch files...")
    patch_dir = Path("./generated_patches")
    created_files = visualizer.generate_patch_files(patches, patch_dir)
    
    print(f"Generated {len(created_files)} patch files:")
    for file_path in created_files:
        print(f"  - {file_path}")
    
    # Display summary
    print(f"\nüìã VISUALIZATION SUMMARY:")
    print(f"  Text Report: {text_output}")
    print(f"  Patch Files: {patch_dir}")
    print(f"  Critical Issues: {report.critical_issues}")
    print(f"  Generated Patches: {len(patches)}")
    
    print("\n‚úÖ Visualizer tests complete!")
    print("\nüéØ WHAT YOU NEED TO PATCH:")
    
    critical_issues = report.get_critical_issues()
    for issue in critical_issues:
        print(f"\nüö® {issue.title}")
        print(f"   Problem: {issue.description}")
        print(f"   Mods: {' ‚Üí '.join(issue.conflicting_mods)}")
        print(f"   Solution: Apply patch {patches[0].patch_id if patches else 'N/A'}")
    
    return report, patches, visualizer

if __name__ == "__main__":
    test_visualizer() 